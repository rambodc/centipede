this.CABLES=this.CABLES||{},this.CABLES.COREMODULES=this.CABLES.COREMODULES||{},this.CABLES.COREMODULES.Ammodebugdrawer=function(e){var t={};function i(r){if(t[r])return t[r].exports;var s=t[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,i),s.l=!0,s.exports}return i.m=e,i.c=t,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)i.d(r,s,function(t){return e[t]}.bind(null,s));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=0)}([function(e,t){const i=1;CABLES.AmmoDebugDrawer=class{constructor(e,t){this.world=e,t=t||{},this.verts=[],this._lineGeom=null,this._lineMesh=null,this.debugDrawMode=t.debugDrawMode||i,this.index=0,this.enabled=!0,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawTriangle=this.drawTriangle.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.debugDrawer.enable=this.enable.bind(this),this.debugDrawer.disable=this.disable.bind(this),this.debugDrawer.update=this.update.bind(this),this.debugDrawer.enabled=!0,this.world.setDebugDrawer(this.debugDrawer),this._lineShader=null,this._shaderFrag="".endl()+"precision highp float;".endl()+"IN vec4 vertCol;".endl()+"void main()".endl()+"{".endl()+"    outColor = vertCol;".endl()+"}",this._shaderVert="".endl()+"IN vec3 vPosition;".endl()+"UNI mat4 projMatrix;".endl()+"UNI mat4 mvMatrix;".endl()+"OUT vec4 vertCol;".endl()+"IN vec4 attrVertColor;".endl()+"void main()".endl()+"{".endl()+"   vec4 pos=vec4(vPosition, 1.0);".endl()+"   vertCol=attrVertColor;".endl()+"   gl_PointSize=20.0;".endl()+"   gl_Position = projMatrix * mvMatrix * pos;".endl()+"}"}enable(){this.enabled=!0}disable(){this.enabled=!1}render(e){this.enabled&&(this._lineShader||(this._lineShader=new CGL.Shader(e,"ammoDebugLineShader"),this._lineShader.setSource(this._shaderVert,this._shaderFrag)),this._lineGeom||(this._lineGeom=new CGL.Geometry("ammoDebugLines"),this._lineMesh=new CGL.Mesh(e,this._lineGeom,e.gl.LINES),this._lineMesh.setGeom(this._lineGeom),this._lineGeom.vertices=[],this._pointGeom=new CGL.Geometry("ammoDebugPoints"),this._pointMesh=new CGL.Mesh(e,this._pointGeom,e.gl.LINES),this._pointMesh.setGeom(this._pointGeom),this._pointGeom.vertices=[]),this._lineShader.glPrimitive=e.gl.LINES,this._lineMesh.render(this._lineShader),this._lineShader.glPrimitive=e.gl.POINTS,this._pointMesh.render(this._lineShader))}update(){this._lineGeom&&(this.index=0,this.verts=[],this.vertCols=[],this.indexPoints=0,this.vertPoints=[],this.vertPointCols=[],this.world.debugDrawWorld(),this._lineGeom.setPointVertices(this.verts),this._lineGeom.vertexColors=this.vertCols,this._lineMesh.setGeom(this._lineGeom),this._pointGeom.setPointVertices(this.vertPoints),this._pointGeom.vertexColors=this.vertPointCols,this._pointMesh.setGeom(this._pointGeom))}drawContactPoint(e,t,i,r,s){const n=Ammo.HEAPF32,o=n[(s+0)/4],h=n[(s+4)/4],d=n[(s+8)/4],l=n[(e+0)/4],a=n[(e+4)/4],u=n[(e+8)/4];let b=3*this.indexPoints,g=4*this.indexPoints;this.vertPoints[b+0]=l,this.vertPoints[b+1]=a,this.vertPoints[b+2]=u,this.vertPointCols[g+0]=o,this.vertPointCols[g+1]=h,this.vertPointCols[g+2]=d,this.vertPointCols[g+3]=1,this.indexPoints++}drawTriangle(e,t,i,r){console.log("draw triangle!"),this.drawLine(e,t,r),this.drawLine(t,i,r),this.drawLine(e,i,r)}drawLine(e,t,i){let r=3*this.index,s=4*this.index;const n=Ammo.HEAPF32,o=n[(i+0)/4],h=n[(i+4)/4],d=n[(i+8)/4];this.vertCols[s+0]=o,this.vertCols[s+1]=h,this.vertCols[s+2]=d,this.vertCols[s+3]=.6;const l=n[(e+0)/4],a=n[(e+4)/4],u=n[(e+8)/4];this.verts[r+0]=l,this.verts[r+1]=a,this.verts[r+2]=u;const b=n[(t+0)/4],g=n[(t+4)/4],m=n[(t+8)/4];this.index++,r=3*this.index,s=4*this.index,this.verts[r+0]=b,this.verts[r+1]=g,this.verts[r+2]=m,this.vertCols[s+0]=o,this.vertCols[s+1]=h,this.vertCols[s+2]=d,this.vertCols[s+3]=.6,this.index++}reportErrorWarning(e){Ammo.hasOwnProperty("UTF8ToString")?console.warn(Ammo.UTF8ToString(e)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please export UTF8ToString from Ammo.js in make.py"))}draw3dText(e,t){console.warn("TODO: draw3dText")}setDebugMode(e){this.debugDrawMode=e}getDebugMode(){return this.debugDrawMode}}}]).Cables;